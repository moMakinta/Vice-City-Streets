<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo City - Smart Open World</title>
    <link rel="stylesheet" href="vcstyles.css">
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen">
            <h1 style="font-size: 2.5em; margin-bottom: 20px; color: #40e0d0; font-weight: 700;">NEO CITY</h1>
            <p style="font-size: 1.1em; margin-bottom: 30px; color: #a0a0a0; font-weight: 300;">Smart Open World Experience</p>
            <p style="margin-bottom: 30px; line-height: 1.6; color: #c0c0c0;">
                WASD - Move/Drive • SPACE - Shoot/Brake<br>
                E - Enter/Exit Vehicle • R - Accept Mission<br>
                Mouse - Aim & Shoot
            </p>
            <button class="btn" onclick="startGame()">Enter Neo City</button>
        </div>
        
        <div id="hud">
            <div class="stat">
                <span>Credits</span>
                <span style="color: #40e0d0; font-weight: 600;">$<span id="money">0</span></span>
            </div>
            <div class="stat">
                <span>Health</span>
                <span id="healthPercent">100%</span>
            </div>
            <div class="health-bar">
                <div class="health-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div class="stat">
                <span>Heat Level</span>
                <span id="wantedLevel" style="color: #ff6b6b;">0</span>
            </div>
        </div>
        
        <canvas id="minimap" width="220" height="160"></canvas>
        
        <div id="missionPanel">
            <h3 style="color: #40e0d0; margin-bottom: 12px; font-weight: 600;">MISSION BRIEFING</h3>
            <div id="missionContent">
                <p id="missionText">Explore the city and press R near mission markers</p>
            </div>
            <div id="missionProgress" style="display: none;">
                <div class="mission-objective">
                    <div style="font-weight: 600; margin-bottom: 4px;" id="objective">Objective</div>
                    <div style="font-size: 12px; color: #a0a0a0;" id="progressText">0/0</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="notification" class="notification">
            <div id="notificationText">Mission Complete!</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');
        
        // Game state
        let gameRunning = false;
        let money = 0;
        let wantedLevel = 0;
        let health = 100;
        let keys = {};
        let mousePos = { x: 0, y: 0 };
        let camera = { x: 0, y: 0 };
        
        // World configuration
        const WORLD_WIDTH = 2400;
        const WORLD_HEIGHT = 1600;
        const BLOCK_SIZE = 120;
        const ROAD_WIDTH = 24;
        
        // Player
        let player = {
            x: WORLD_WIDTH / 2,
            y: WORLD_HEIGHT / 2,
            width: 16,
            height: 16,
            speed: 3.5,
            angle: 0,
            inVehicle: false,
            vehicle: null
        };
        
        // Game objects
        let vehicles = [];
        let buildings = [];
        let npcs = [];
        let bullets = [];
        let missionMarkers = [];
        let currentMission = null;
        let aiVehicles = [];
        
        // AI Mission system
        const missionTypes = [
            {
                type: 'delivery',
                name: 'Package Delivery',
                description: 'Deliver packages to marked locations',
                reward: 500,
                difficulty: 1
            },
            {
                type: 'chase',
                name: 'High Speed Pursuit',
                description: 'Chase down the target vehicle',
                reward: 800,
                difficulty: 2
            },
            {
                type: 'collect',
                name: 'Data Recovery',
                description: 'Collect scattered data chips',
                reward: 600,
                difficulty: 1
            },
            {
                type: 'escort',
                name: 'VIP Protection',
                description: 'Escort VIP safely to destination',
                reward: 1000,
                difficulty: 3
            }
        ];
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyE' && gameRunning) toggleVehicle();
            if (e.code === 'KeyR' && gameRunning) checkMissionStart();
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('click', (e) => {
            if (gameRunning && !player.inVehicle) shoot();
        });
        
        // World generation with proper city layout
        function generateCity() {
            buildings = [];
            
            // Create city blocks with proper spacing
            for (let x = 0; x < WORLD_WIDTH; x += BLOCK_SIZE + ROAD_WIDTH) {
                for (let y = 0; y < WORLD_HEIGHT; y += BLOCK_SIZE + ROAD_WIDTH) {
                    // Skip some blocks for variety
                    if (Math.random() > 0.85) continue;
                    
                    // Create multiple buildings per block
                    const buildingsPerBlock = Math.floor(Math.random() * 4) + 2;
                    for (let i = 0; i < buildingsPerBlock; i++) {
                        const buildingWidth = 30 + Math.random() * 40;
                        const buildingHeight = 30 + Math.random() * 50;
                        const buildingX = x + Math.random() * (BLOCK_SIZE - buildingWidth);
                        const buildingY = y + Math.random() * (BLOCK_SIZE - buildingHeight);
                        
                        buildings.push({
                            x: buildingX,
                            y: buildingY,
                            width: buildingWidth,
                            height: buildingHeight,
                            color: `hsl(${220 + Math.random() * 40}, 20%, ${15 + Math.random() * 15}%)`,
                            windows: generateWindows(buildingWidth, buildingHeight)
                        });
                    }
                }
            }
        }
        
        function generateWindows(width, height) {
            const windows = [];
            const windowSize = 4;
            const spacing = 8;
            
            for (let x = spacing; x < width - windowSize; x += spacing) {
                for (let y = spacing; y < height - windowSize; y += spacing) {
                    if (Math.random() > 0.3) {
                        windows.push({
                            x: x,
                            y: y,
                            lit: Math.random() > 0.6
                        });
                    }
                }
            }
            return windows;
        }
        
        function initWorld() {
            generateCity();
            
            // Create vehicles with AI
            vehicles = [];
            aiVehicles = [];
            for (let i = 0; i < 15; i++) {
                const vehicle = {
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    width: 32,
                    height: 16,
                    speed: 2 + Math.random() * 2,
                    angle: Math.random() * Math.PI * 2,
                    color: `hsl(${Math.random() * 360}, 60%, 50%)`,
                    occupied: false,
                    health: 100,
                    ai: {
                        target: null,
                        behavior: 'patrol', // patrol, chase, flee
                        pathfinding: [],
                        lastDirectionChange: 0
                    }
                };
                vehicles.push(vehicle);
                if (Math.random() > 0.7) aiVehicles.push(vehicle);
            }
            
            // Create smart NPCs
            npcs = [];
            for (let i = 0; i < 25; i++) {
                npcs.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    width: 12,
                    height: 12,
                    speed: 1 + Math.random(),
                    angle: Math.random() * Math.PI * 2,
                    color: `hsl(${Math.random() * 360}, 40%, 60%)`,
                    health: 50,
                    ai: {
                        behavior: 'wander',
                        target: null,
                        alertLevel: 0,
                        lastSeen: null
                    }
                });
            }
            
            // Create mission markers
            generateMissionMarkers();
        }
        
        function generateMissionMarkers() {
            missionMarkers = [];
            for (let i = 0; i < 5; i++) {
                missionMarkers.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    active: true,
                    missionType: missionTypes[Math.floor(Math.random() * missionTypes.length)],
                    pulse: 0
                });
            }
        }
        
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameRunning = true;
            initWorld();
            gameLoop();
        }
        
        function toggleVehicle() {
            if (player.inVehicle) {
                player.inVehicle = false;
                player.vehicle.occupied = false;
                player.x = player.vehicle.x + 40;
                player.y = player.vehicle.y;
                player.vehicle = null;
                player.speed = 3.5;
            } else {
                const nearbyVehicle = vehicles.find(v => 
                    !v.occupied && 
                    Math.abs(v.x - player.x) < 40 && 
                    Math.abs(v.y - player.y) < 40
                );
                
                if (nearbyVehicle) {
                    player.inVehicle = true;
                    player.vehicle = nearbyVehicle;
                    nearbyVehicle.occupied = true;
                    player.speed = 5;
                }
            }
        }
        
        function checkMissionStart() {
            const nearbyMarker = missionMarkers.find(m => 
                m.active && 
                Math.abs(m.x - player.x) < 50 && 
                Math.abs(m.y - player.y) < 50
            );
            
            if (nearbyMarker && !currentMission) {
                startMission(nearbyMarker.missionType);
                nearbyMarker.active = false;
            }
        }
        
        function startMission(missionType) {
            currentMission = {
                ...missionType,
                progress: 0,
                target: 3 + Math.floor(Math.random() * 3),
                timeLeft: 90000,
                startTime: Date.now(),
                objectives: []
            };
            
            // Generate mission objectives based on type
            generateMissionObjectives(currentMission);
            
            document.getElementById('missionPanel').classList.add('active');
            document.getElementById('missionText').textContent = missionType.description;
            document.getElementById('missionProgress').style.display = 'block';
            updateMissionDisplay();
        }
        
        function generateMissionObjectives(mission) {
            mission.objectives = [];
            
            switch (mission.type) {
                case 'delivery':
                    for (let i = 0; i < mission.target; i++) {
                        mission.objectives.push({
                            x: Math.random() * WORLD_WIDTH,
                            y: Math.random() * WORLD_HEIGHT,
                            completed: false,
                            type: 'delivery'
                        });
                    }
                    break;
                    
                case 'chase':
                    // Create target vehicle
                    const targetVehicle = {
                        x: Math.random() * WORLD_WIDTH,
                        y: Math.random() * WORLD_HEIGHT,
                        width: 32,
                        height: 16,
                        speed: 4,
                        angle: Math.random() * Math.PI * 2,
                        color: '#ff4444',
                        ai: { behavior: 'flee', target: player }
                    };
                    vehicles.push(targetVehicle);
                    mission.targetVehicle = targetVehicle;
                    break;
                    
                case 'collect':
                    for (let i = 0; i < mission.target; i++) {
                        mission.objectives.push({
                            x: Math.random() * WORLD_WIDTH,
                            y: Math.random() * WORLD_HEIGHT,
                            completed: false,
                            type: 'collect'
                        });
                    }
                    break;
            }
        }
        
        function updateAI() {
            // Update NPC AI
            npcs.forEach(npc => {
                const distToPlayer = Math.sqrt(
                    Math.pow(npc.x - player.x, 2) + Math.pow(npc.y - player.y, 2)
                );
                
                if (distToPlayer < 100 && wantedLevel > 2) {
                    // Flee from player if wanted
                    npc.ai.behavior = 'flee';
                    npc.angle = Math.atan2(npc.y - player.y, npc.x - player.x);
                } else if (distToPlayer > 200) {
                    npc.ai.behavior = 'wander';
                }
                
                // Execute behavior
                switch (npc.ai.behavior) {
                    case 'wander':
                        if (Math.random() < 0.02) {
                            npc.angle += (Math.random() - 0.5) * 0.5;
                        }
                        break;
                    case 'flee':
                        npc.speed = 2;
                        break;
                }
                
                npc.x += Math.cos(npc.angle) * npc.speed;
                npc.y += Math.sin(npc.angle) * npc.speed;
                
                // Keep in bounds
                if (npc.x < 0 || npc.x > WORLD_WIDTH) npc.angle = Math.PI - npc.angle;
                if (npc.y < 0 || npc.y > WORLD_HEIGHT) npc.angle = -npc.angle;
            });
            
            // Update AI vehicles
            aiVehicles.forEach(vehicle => {
                if (vehicle.occupied) return;
                
                const now = Date.now();
                if (now - vehicle.ai.lastDirectionChange > 3000) {
                    vehicle.ai.lastDirectionChange = now;
                    
                    // Simple pathfinding - avoid buildings
                    const ahead = {
                        x: vehicle.x + Math.cos(vehicle.angle) * 60,
                        y: vehicle.y + Math.sin(vehicle.angle) * 60
                    };
                    
                    const collision = buildings.some(building => 
                        ahead.x > building.x && ahead.x < building.x + building.width &&
                        ahead.y > building.y && ahead.y < building.y + building.height
                    );
                    
                    if (collision) {
                        vehicle.angle += Math.PI / 2 + (Math.random() - 0.5) * Math.PI / 4;
                    }
                }
                
                vehicle.x += Math.cos(vehicle.angle) * vehicle.speed;
                vehicle.y += Math.sin(vehicle.angle) * vehicle.speed;
                
                // Keep in bounds
                if (vehicle.x < 0 || vehicle.x > WORLD_WIDTH) vehicle.angle = Math.PI - vehicle.angle;
                if (vehicle.y < 0 || vehicle.y > WORLD_HEIGHT) vehicle.angle = -vehicle.angle;
            });
        }
        
        function shoot() {
            const angle = Math.atan2(
                mousePos.y - canvas.height / 2,
                mousePos.x - canvas.width / 2
            );
            
            bullets.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle) * 8,
                vy: Math.sin(angle) * 8,
                life: 80,
                fromPlayer: true
            });
            
            wantedLevel = Math.min(5, wantedLevel + 0.2);
        }
        
        function updatePlayer() {
            if (player.inVehicle && player.vehicle) {
                if (keys['KeyW'] || keys['ArrowUp']) {
                    player.vehicle.x += Math.cos(player.vehicle.angle) * player.vehicle.speed;
                    player.vehicle.y += Math.sin(player.vehicle.angle) * player.vehicle.speed;
                }
                if (keys['KeyS'] || keys['ArrowDown']) {
                    player.vehicle.x -= Math.cos(player.vehicle.angle) * player.vehicle.speed * 0.5;
                    player.vehicle.y -= Math.sin(player.vehicle.angle) * player.vehicle.speed * 0.5;
                }
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    player.vehicle.angle -= 0.08;
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    player.vehicle.angle += 0.08;
                }
                
                player.x = player.vehicle.x;
                player.y = player.vehicle.y;
                player.angle = player.vehicle.angle;
            } else {
                if (keys['KeyW'] || keys['ArrowUp']) player.y -= player.speed;
                if (keys['KeyS'] || keys['ArrowDown']) player.y += player.speed;
                if (keys['KeyA'] || keys['ArrowLeft']) player.x -= player.speed;
                if (keys['KeyD'] || keys['ArrowRight']) player.x += player.speed;
            }
            
            player.x = Math.max(0, Math.min(WORLD_WIDTH, player.x));
            player.y = Math.max(0, Math.min(WORLD_HEIGHT, player.y));
            
            // Smooth camera follow
            const targetCameraX = player.x - canvas.width / 2;
            const targetCameraY = player.y - canvas.height / 2;
            camera.x += (targetCameraX - camera.x) * 0.1;
            camera.y += (targetCameraY - camera.y) * 0.1;
            
            camera.x = Math.max(0, Math.min(WORLD_WIDTH - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_HEIGHT - canvas.height, camera.y));
        }
        
        function updateMissions() {
            if (!currentMission) return;
            
            // Check mission objectives
            if (currentMission.objectives) {
                currentMission.objectives.forEach((obj, index) => {
                    if (!obj.completed) {
                        const dist = Math.sqrt(
                            Math.pow(obj.x - player.x, 2) + Math.pow(obj.y - player.y, 2)
                        );
                        
                        if (dist < 30) {
                            obj.completed = true;
                            currentMission.progress++;
                            showNotification('+$100 Objective Complete');
                            money += 100;
                        }
                    }
                });
            }
            
            // Check mission completion
            if (currentMission.progress >= currentMission.target) {
                completeMission();
            }
            
            updateMissionDisplay();
        }
        
        function completeMission() {
            money += currentMission.reward;
            showNotification(`Mission Complete! +$${currentMission.reward}`);
            
            document.getElementById('missionPanel').classList.remove('active');
            currentMission = null;
            
            // Generate new mission markers
            setTimeout(() => {
                generateMissionMarkers();
            }, 5000);
        }
        
        function updateMissionDisplay() {
            if (!currentMission) return;
            
            document.getElementById('objective').textContent = currentMission.name;
            document.getElementById('progressText').textContent = 
                `${currentMission.progress}/${currentMission.target}`;
            
            const progressPercent = (currentMission.progress / currentMission.target) * 100;
            document.getElementById('progressBar').style.width = progressPercent + '%';
        }
        
        function showNotification(text) {
            const notification = document.getElementById('notification');
            document.getElementById('notificationText').textContent = text;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }
        
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;
                return bullet.life > 0;
            });
        }
        
        function drawWorld() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw roads
            ctx.fillStyle = '#2a2a3a';
            
            // Horizontal roads
            for (let y = 0; y < WORLD_HEIGHT; y += BLOCK_SIZE + ROAD_WIDTH) {
                ctx.fillRect(0 - camera.x, y - camera.y, WORLD_WIDTH, ROAD_WIDTH);
                
                // Road markings
                ctx.fillStyle = '#4a4a5a';
                for (let x = 0; x < WORLD_WIDTH; x += 40) {
                    ctx.fillRect(x - camera.x, y + ROAD_WIDTH/2 - 1 - camera.y, 20, 2);
                }
                ctx.fillStyle = '#2a2a3a';
            }
            
            // Vertical roads
            for (let x = 0; x < WORLD_WIDTH; x += BLOCK_SIZE + ROAD_WIDTH) {
                ctx.fillRect(x - camera.x, 0 - camera.y, ROAD_WIDTH, WORLD_HEIGHT);
                
                // Road markings
                ctx.fillStyle = '#4a4a5a';
                for (let y = 0; y < WORLD_HEIGHT; y += 40) {
                    ctx.fillRect(x + ROAD_WIDTH/2 - 1 - camera.x, y - camera.y, 2, 20);
                }
                ctx.fillStyle = '#2a2a3a';
            }
            
            // Draw buildings
            buildings.forEach(building => {
                const screenX = building.x - camera.x;
                const screenY = building.y - camera.y;
                
                if (screenX > -building.width && screenX < canvas.width &&
                    screenY > -building.height && screenY < canvas.height) {
                    
                    // Building shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(screenX + 2, screenY + 2, building.width, building.height);
                    
                    // Building
                    ctx.fillStyle = building.color;
                    ctx.fillRect(screenX, screenY, building.width, building.height);
                    
                    // Windows
                    building.windows.forEach(window => {
                        ctx.fillStyle = window.lit ? '#ffeb3b' : '#1a1a2e';
                        ctx.fillRect(screenX + window.x, screenY + window.y, 4, 4);
                    });
                    
                    // Building outline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(screenX, screenY, building.width, building.height);
                }
            });
            
            // Draw mission markers
            missionMarkers.forEach(marker => {
                if (!marker.active) return;
                
                const screenX = marker.x - camera.x;
                const screenY = marker.y - camera.y;
                
                if (screenX > -50 && screenX < canvas.width + 50 &&
                    screenY > -50 && screenY < canvas.height + 50) {
                    
                    marker.pulse += 0.1;
                    const pulseSize = 20 + Math.sin(marker.pulse) * 5;
                    
                    ctx.fillStyle = `rgba(64, 224, 208, ${0.3 + Math.sin(marker.pulse) * 0.2})`;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#40e0d0';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw mission objectives
            if (currentMission && currentMission.objectives) {
                currentMission.objectives.forEach(obj => {
                    if (obj.completed) return;
                    
                    const screenX = obj.x - camera.x;
                    const screenY = obj.y - camera.y;
                    
                    ctx.fillStyle = '#ffeb3b';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffc107';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
            
            // Draw vehicles
            vehicles.forEach(vehicle => {
                const screenX = vehicle.x - camera.x;
                const screenY = vehicle.y - camera.y;
                
                if (screenX > -50 && screenX < canvas.width + 50 &&
                    screenY > -50 && screenY < canvas.height + 50) {
                    
                    ctx.save();
                    ctx.translate(screenX + vehicle.width/2, screenY + vehicle.height/2);
                    ctx.rotate(vehicle.angle);
                    
                    // Vehicle shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(-vehicle.width/2 + 1, -vehicle.height/2 + 1, vehicle.width, vehicle.height);
                    
                    // Vehicle body
                    ctx.fillStyle = vehicle.color;
                    ctx.fillRect(-vehicle.width/2, -vehicle.height/2, vehicle.width, vehicle.height);
                    
                    // Vehicle details
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(-vehicle.width/2 + 4, -vehicle.height/2 + 2, vehicle.width - 8, vehicle.height - 4);
                    
                    // Headlights
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(vehicle.width/2 - 2, -vehicle.height/2, 2, 3);
                    ctx.fillRect(vehicle.width/2 - 2, vehicle.height/2 - 3, 2, 3);
                    
                    ctx.restore();
                }
            });
            
            // Draw NPCs
            npcs.forEach(npc => {
                const screenX = npc.x - camera.x;
                const screenY = npc.y - camera.y;
                
                if (screenX > -20 && screenX < canvas.width + 20 &&
                    screenY > -20 && screenY < canvas.height + 20) {
                    
                    ctx.fillStyle = npc.color;
                    ctx.beginPath();
                    ctx.arc(screenX + npc.width/2, screenY + npc.height/2, npc.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Simple direction indicator
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    const dirX = screenX + npc.width/2 + Math.cos(npc.angle) * 4;
                    const dirY = screenY + npc.height/2 + Math.sin(npc.angle) * 4;
                    ctx.beginPath();
                    ctx.arc(dirX, dirY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw bullets
            bullets.forEach(bullet => {
                const screenX = bullet.x - camera.x;
                const screenY = bullet.y - camera.y;
                
                ctx.fillStyle = bullet.fromPlayer ? '#40e0d0' : '#ff6b6b';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw player
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;
            
            if (player.inVehicle && player.vehicle) {
                ctx.save();
                ctx.translate(screenX + player.vehicle.width/2, screenY + player.vehicle.height/2);
                ctx.rotate(player.angle);
                
                // Vehicle glow for player
                ctx.shadowColor = '#40e0d0';
                ctx.shadowBlur = 10;
                ctx.fillStyle = player.vehicle.color;
                ctx.fillRect(-player.vehicle.width/2, -player.vehicle.height/2, player.vehicle.width, player.vehicle.height);
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(-player.vehicle.width/2 + 4, -player.vehicle.height/2 + 2, player.vehicle.width - 8, player.vehicle.height - 4);
                
                ctx.restore();
            } else {
                ctx.fillStyle = '#40e0d0';
                ctx.shadowColor = '#40e0d0';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(screenX + player.width/2, screenY + player.height/2, player.width/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Player direction
                ctx.fillStyle = '#ffffff';
                const dirX = screenX + player.width/2 + Math.cos(player.angle) * 6;
                const dirY = screenY + player.height/2 + Math.sin(player.angle) * 6;
                ctx.beginPath();
                ctx.arc(dirX, dirY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawMinimap() {
            minimapCtx.clearRect(0, 0, 220, 160);
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 220, 160);
            
            const scaleX = 220 / WORLD_WIDTH;
            const scaleY = 160 / WORLD_HEIGHT;
            
            // Draw roads on minimap
            minimapCtx.fillStyle = '#444';
            for (let x = 0; x < WORLD_WIDTH; x += BLOCK_SIZE + ROAD_WIDTH) {
                minimapCtx.fillRect(x * scaleX, 0, ROAD_WIDTH * scaleX, 160);
            }
            for (let y = 0; y < WORLD_HEIGHT; y += BLOCK_SIZE + ROAD_WIDTH) {
                minimapCtx.fillRect(0, y * scaleY, 220, ROAD_WIDTH * scaleY);
            }
            
            // Draw buildings on minimap
            minimapCtx.fillStyle = '#666';
            buildings.forEach(building => {
                minimapCtx.fillRect(
                    building.x * scaleX,
                    building.y * scaleY,
                    building.width * scaleX,
                    building.height * scaleY
                );
            });
            
            // Draw mission markers
            minimapCtx.fillStyle = '#40e0d0';
            missionMarkers.forEach(marker => {
                if (marker.active) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(marker.x * scaleX, marker.y * scaleY, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Draw player on minimap
            minimapCtx.fillStyle = '#40e0d0';
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scaleX, player.y * scaleY, 4, 0, Math.PI * 2);
            minimapCtx.fill();
            minimapCtx.stroke();
        }
        
        function updateUI() {
            document.getElementById('money').textContent = money;
            document.getElementById('healthBar').style.width = health + '%';
            document.getElementById('healthPercent').textContent = Math.floor(health) + '%';
            document.getElementById('wantedLevel').textContent = Math.floor(wantedLevel);
            
            // Decrease wanted level over time
            if (wantedLevel > 0) {
                wantedLevel = Math.max(0, wantedLevel - 0.01);
            }
        }
        
        function gameLoop() {
            if (!gameRunning) return;
            
            updatePlayer();
            updateBullets();
            updateAI();
            updateMissions();
            
            drawWorld();
            drawMinimap();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9765701723976cb8',t:'MTc1NjQwMTE5MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
